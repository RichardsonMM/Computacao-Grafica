//
//  main.cpp
//  09-3D-Iluminacao
//
//  Created by Viapiana on 29/05/17.
//  Copyright © 2017 Viapas. All rights reserved.
//
// Iluminacao


#include <iostream>
#include <cstdlib>
#include <math.h>
#include <sstream>

#if __APPLE__
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#include <GLUT/glut.h>
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#else
#include <gl/glut.h>
#include <GL/freeglut.h>
#endif

#ifndef M_PI
#define M_PI 3.1415926
#endif

using namespace std;

#define JANELAS         3

#define LAR_MAIN        600
#define ALT_MAIN        600

#define LAR_INFO        155
#define ALT_INFO        60

#define LAR_HELP        600
#define ALT_HELP        225

#define NUM_TEX         3
#define TEXTURA0        1000
#define TEXTURA1        1001
#define TEXTURA2        1002

// prototipagem
//void especifica_parametros_visualizacao( void );

struct tipo_camera {
    GLfloat posx;               // posicao x da camera
    GLfloat posy;               // posicao y da camera
    GLfloat posz;               // posicao z da camera
    GLfloat alvox;              // alvo x da visualizacao
    GLfloat alvoy;              // alvo y da visualizacao
    GLfloat alvoz;              // alvo z da visualizacao
    GLfloat ang;                // abertura da 'lente' - efeito de zoom
    GLfloat inicio;             // inicio da area de visualizacao em profundidade
    GLfloat fim;                // fim da area de visualizacao em profundidade
};

struct tipo_transformacao{
    GLfloat dx, dy, dz;         // paramatros de translacao
    GLfloat sx, sy, sz;         // parametros de escala
    GLfloat angx , angy , angz; // parametros de rotacao
};

struct tipo_janela{
    GLfloat largura;            // largura da janela
    GLfloat altura;             // altura da jaanela
    GLfloat aspecto;            // aspecto da janela (relacao entre largura e altura)
};

struct tipo_luz{
    GLfloat difusa[ 4 ];
    GLfloat especular[ 4 ];
    GLfloat posicao[ 4 ];
    bool    ligada;
};

// define a perspectiva da camera
tipo_camera camera;

// definicao dos valores de transformacao
tipo_transformacao transf;

// definicao dos janela principal
tipo_janela janela;

// definicao de uma fonte de luz
tipo_luz luz[ 1 ];

// especularidade e brilho do material
GLfloat especularidade[ 4 ];
GLint   espec_material;
GLfloat ambiente[ 4 ];

// transformacao atual, eixo atual
char  transformacao, eixo, tonalizacao;

// forma do objeto: aramado ou solido
bool  wireframe;

// controle das janelas, passo de atualizacao dos parametros das transformacoes e qual objeto mostrar
GLint jan[ JANELAS ], passo, primitiva;


GLuint  texture_id[ NUM_TEX ];

// =======================================================================
int  LoadBMP(char *filename)
{
    #define SAIR        {fclose(fp_arquivo); return -1;}
    #define CTOI(C)     (*(int*)&C)

    GLubyte     *image;
    GLubyte     Header[0x54];
    GLuint      DataPos, imageSize;
    GLsizei     Width,Height;

    // Abre o arquivo e efetua a leitura do Header do arquivo BMP
    FILE * fp_arquivo = fopen(filename,"rb");
    if (!fp_arquivo)
    {
        cout << endl << "Nao pode abrir o arquivo " << filename << endl;
        return -1;
    }
    else
        cout << endl << "Sucesso na abertura do arquivo " << filename << endl;

    if (fread(Header,1,0x36,fp_arquivo)!=0x36)
        SAIR;
    if (Header[0]!='B' || Header[1]!='M')
        SAIR;
    if (CTOI(Header[0x1E])!=0)
        SAIR;
    if (CTOI(Header[0x1C])!=24)
        SAIR;

    // Recupera a informaÁ„o dos atributos de
    // altura e largura da imagem

    Width   = CTOI(Header[0x12]);
    Height  = CTOI(Header[0x16]);
    ( CTOI(Header[0x0A]) == 0 ) ? ( DataPos=0x36 ) : ( DataPos = CTOI(Header[0x0A]) );

    imageSize=Width*Height*3;

    // Efetura a Carga da Imagem
    image = (GLubyte *) malloc ( imageSize );
    int retorno;
    retorno = fread(image,1,imageSize,fp_arquivo);

    if (retorno !=imageSize)
    {
        free (image);
        SAIR;
    }

    // Inverte os valores de R e B
    int t, i;

    for ( i = 0; i < imageSize; i += 3 )
    {
        t = image[i];
        image[i] = image[i+2];
        image[i+2] = t;
    }

    // Tratamento da textura para o OpenGL
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S    ,GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T    ,GL_REPEAT);

    glTexEnvf ( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );

    // Faz a geraÁao da textura na memÛria
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, Width, Height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);

    fclose (fp_arquivo);
    free (image);
    return 1;
}

// =======================================================================
void Texturizacao() //faz o carregamento
{
    glEnable(GL_TEXTURE_2D);
    glPixelStorei ( GL_UNPACK_ALIGNMENT, 1 );//Como armazena o pixel
    glGenTextures ( NUM_TEX , texture_id );//armazena q qtidade de textura

    texture_id[ 0 ] = TEXTURA0; // define um numero (identificacao) para a textura
    glBindTexture ( GL_TEXTURE_2D, texture_id[0] );//armazena na posicao 0 do vetor
    LoadBMP ( "bolas.bmp" ); // le a textura

    texture_id[ 1 ] = TEXTURA1;
    glBindTexture ( GL_TEXTURE_2D, texture_id[1] );
    LoadBMP ( "girassol.bmp" );

    texture_id[ 2 ] = TEXTURA2;
    glBindTexture ( GL_TEXTURE_2D, texture_id[2] );
    LoadBMP ( "inter.bmp" );

    glTexGeni( GL_S , GL_TEXTURE_GEN_MODE , GL_SPHERE_MAP );
    glTexGeni( GL_T , GL_TEXTURE_GEN_MODE , GL_SPHERE_MAP );
}

// =======================================================================
void piramide( int t , int w )
{
    t = t / 2;

    if ( w )
        glBegin( GL_POLYGON );
    else
        glBegin( GL_LINE_LOOP );
    //FRONTAL
    glBegin( GL_POLYGON );
    glNormal3f(   0.0 ,   0.0 ,  0.5 );    // Normal da face
    glVertex3f( 0.0 ,   t , 0.0 );
    glVertex3f(  -t , 0.0 ,   t );
    glVertex3f(   t , 0.0 ,   t );
    glEnd();

    if ( w )
        glBegin( GL_POLYGON );
    else
        glBegin( GL_LINE_LOOP );
    //ESQUERDA
    glBegin( GL_POLYGON );
    glNormal3f(   0.5 ,   0.0 ,  0.0 );    // Normal da face
    glVertex3f( 0.0 ,   t , 0.0 );
    glVertex3f(   t , 0.0 ,   t );
    glVertex3f(   t , 0.0 ,  -t );
    glEnd();

    if ( w )
        glBegin( GL_POLYGON );
    else
        glBegin( GL_LINE_LOOP );
    //TRASEIRA
    glBegin( GL_POLYGON );
    glNormal3f(   0.0 ,   0.0 , -0.5 );    // Normal da face
    glVertex3f( 0.0 ,   t , 0.0 );
    glVertex3f(   t , 0.0 ,  -t );
    glVertex3f(  -t , 0.0 ,  -t );
    glEnd();

    if ( w )
        glBegin( GL_POLYGON );
    else
        glBegin( GL_LINE_LOOP );
    //DIREITA
    glBegin( GL_POLYGON );
    glNormal3f(  -0.5 ,   0.0 ,  0.0 );    // Normal da face
    glVertex3f( 0.0 ,   t , 0.0 );
    glVertex3f(  -t , 0.0 ,  -t );
    glVertex3f(  -t , 0.0 ,   t );
    glEnd();

    if ( w )
        glBegin( GL_POLYGON );
    else
        glBegin( GL_LINE_LOOP );
    //BASE
    glBegin( GL_POLYGON );
    glNormal3f(   0.0 ,  -1.0 ,  0.0 );    // Normal da face
    glVertex3f(  t , 0.0 ,  t );
    glVertex3f( -t , 0.0 ,  t );
    glVertex3f( -t , 0.0 , -t );
    glVertex3f(  t , 0.0 , -t );
    glEnd();
}

// =======================================================================
void cubo( int t , int w )
{
    t = t / 2;

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face frontal
    glNormal3f(   0.0 ,   0.0 ,  1.0 );    // Normal da face
    glVertex3f(  t ,  t , t );
    glVertex3f( -t ,  t , t );
    glVertex3f( -t , -t , t );
    glVertex3f(  t , -t , t );
    glEnd();
    glEnd();

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face traseira
    glNormal3f(   0.0 ,   0.0 ,  -1.0 );    // Normal da face
    glVertex3f(  t , -t , -t );
    glVertex3f( -t , -t , -t );
    glVertex3f( -t ,  t , -t );
    glVertex3f(  t ,  t , -t );
    glEnd();

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face superior
    glNormal3f(   0.0 ,   1.0 ,  0.0 );    // Normal da face
    glVertex3f(  t ,  t , -t );
    glVertex3f( -t ,  t , -t );
    glVertex3f( -t ,  t ,  t );
    glVertex3f(  t ,  t ,  t );
    glEnd();

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face inferior
    glNormal3f(   0.0 ,   -1.0 ,  0.0 );    // Normal da face
    glVertex3f(  t ,  -t , -t );
    glVertex3f(  t ,  -t ,  t );
    glVertex3f( -t ,  -t ,  t );
    glVertex3f( -t ,  -t , -t );
    glEnd();

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face esquerda
    glNormal3f(   -1.0 ,   0.0 ,  0.0 );    // Normal da face
    glVertex3f( -t ,   t , -t );
    glVertex3f( -t ,  -t , -t );
    glVertex3f( -t ,  -t ,  t );
    glVertex3f( -t ,   t ,  t );
    glEnd();

    if ( w )
        glBegin( GL_QUADS );
    else
        glBegin( GL_LINE_LOOP );
    // Face direita
    glNormal3f(   1.0 ,   0.0 ,  0.0 );    // Normal da face
    glVertex3f( t ,   t , -t );
    glVertex3f( t ,   t ,  t );
    glVertex3f( t ,  -t ,  t );
    glVertex3f( t ,  -t , -t );
    glEnd();
}


// =======================================================================
void mostra_texto_bitmap( float x , float y , string texto )
{
    glRasterPos2f ( x , y );

    for( int i = 0 ; i < texto.length() ; i++ )
        glutBitmapCharacter( GLUT_BITMAP_8_BY_13 , texto[ i ] );

    // GLUT_BITMAP_8_BY_13
    // GLUT_BITMAP_9_BY_15
    // GLUT_BITMAP_TIMES_ROMAN_10
    // GLUT_BITMAP_TIMES_ROMAN_24
    // GLUT_BITMAP_HELVETICA_10
    // GLUT_BITMAP_HELVETICA_12
    // GLUT_BITMAP_HELVETICA_18
}

// =======================================================================
// Funcao responsavel por mostrar o info
void desenha_info(void)
{
    ostringstream msg1, msg2, msg3;

    // Limpa a janela de visualizao com a cor de fundo especificada
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    // seleciona o tipo de matriz para a visualizacao dos objetos (modelos)
    glMatrixMode(GL_MODELVIEW);

    glColor4f( 1.0 , 1.0 , 0.0 , 1.0 );

    msg1 << "TRANSFORMACAO : " << transformacao;
    msg2 << "         EIXO : " << eixo;
    msg3 << "        PASSO : " << passo;

    mostra_texto_bitmap( 0 ,  3 , msg3.str() );
    mostra_texto_bitmap( 0 , 23 , msg2.str() );
    mostra_texto_bitmap( 0 , 43 , msg1.str() );

    // Executa os comandos OpenGL
    glutSwapBuffers();
}

// =======================================================================
// Funcao usada para especificar a projecao ortogonal do info
void especifica_parametros_visualizacao_info( void )
{
    // seleciona o tipo de matriz para a projecao
    glMatrixMode( GL_PROJECTION );

    // limpa (zera) as matrizes
    glLoadIdentity();

    glClearColor( 0.0 , 0.0 , 0.0 , 1.0 );

    gluOrtho2D(  0 , LAR_INFO , 0 , ALT_INFO );

}

// =======================================================================
// Funcao callback chamada quando o tamanho da janela do info eh alterado
void altera_tamanho_janela_info( GLsizei largura , GLsizei altura )
{
    glutReshapeWindow( LAR_INFO , ALT_INFO );

    especifica_parametros_visualizacao_info();
}

// =======================================================================
// Funcao responsavel por mostrar o help
void desenha_help(void)
{
    // Limpa a janela de visualizao com a cor de fundo especificada
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    // seleciona o tipo de matriz para a visualizacao dos objetos (modelos)
    glMatrixMode(GL_MODELVIEW);

    glClear( GL_COLOR_BUFFER_BIT );
    glColor4f( 1.0 , 1.0 , 0.0 , 1.0 );

    mostra_texto_bitmap( 0 , 210 , "ESC           : finaliza o programa" );
    mostra_texto_bitmap( 0 , 195 , "F             : alterna tonalizacao entre flat e smooth" );
    mostra_texto_bitmap( 0 , 180 , "0 a 8         : seleciona a primitiva" );
    mostra_texto_bitmap( 0 , 165 , "ALT +         : aumenta o passo" );
    mostra_texto_bitmap( 0 , 150 , "ALT -         : diminui o passo" );
    mostra_texto_bitmap( 0 , 135 , "I             : reinicializa" );
    mostra_texto_bitmap( 0 , 120 , "L             : liga/desliga luz" );
    mostra_texto_bitmap( 0 , 105 , "W             : alterna entre wireframe e solido" );
    mostra_texto_bitmap( 0 ,  90 , "X Y Z         : seleciona o eixo" );
    mostra_texto_bitmap( 0 ,  75 , "S R T         : seleciona a transformacao" );
    mostra_texto_bitmap( 0 ,  60 , "A             : aumenta o angulo de abertura da perspectiva (zoom-out)" );
    mostra_texto_bitmap( 0 ,  45 , "a             : diminui o angulo de abertura da perspectiva (zoom-in)" );
    mostra_texto_bitmap( 0 ,  30 , "+ -           : executa a transformacao corrente sobre o eixo corrente" );
    mostra_texto_bitmap( 0 ,  15 , "ALT NAVEGACAO : movimenta a fonte de luz" );
    mostra_texto_bitmap( 0 ,   0 , "NAVEGACAO     : movimenta a camera" );

    // Executa os comandos OpenGL
    glutSwapBuffers();
}

// =======================================================================
// Funcao usada para especificar a projecao ortogonal do help
void especifica_parametros_visualizacao_help( void )
{
    // seleciona o tipo de matriz para a projecao
    glMatrixMode( GL_PROJECTION );

    // limpa (zera) as matrizes
    glLoadIdentity();

    glClearColor( 0.0 , 0.0 , 0.0 , 1.0 );

    gluOrtho2D(  0 , LAR_HELP , 0 , ALT_HELP );

}

// =======================================================================
// Funcao callback chamada quando o tamanho da janela do help eh alterado
void altera_tamanho_janela_help( GLsizei largura , GLsizei altura )
{
    glutReshapeWindow( LAR_HELP , ALT_HELP );

    especifica_parametros_visualizacao_help();
}

// =======================================================================
// Funcao que cunfigura o uso da iluminacao: caracteristicas da fonte de luz,
// caracteristicas do modelo de reflexao e caracteristicas do material
void define_iluminacao( void )
{

    glMaterialfv( GL_FRONT , GL_SPECULAR , especularidade );
    glMateriali( GL_FRONT , GL_SHININESS , espec_material );

    // ativa o uso da luz ambiente - caso a luz 0 seja desligada
    glLightModelfv( GL_LIGHT_MODEL_AMBIENT , ambiente );

    // define os parametros da fonte de luz numero 0
    glLightfv( GL_LIGHT0 , GL_AMBIENT  , ambiente );
    glLightfv( GL_LIGHT0 , GL_DIFFUSE  , luz[ 0 ].difusa );
    glLightfv( GL_LIGHT0 , GL_SPECULAR , luz[ 0 ].especular );
    glLightfv( GL_LIGHT0 , GL_POSITION , luz[ 0 ].posicao );

    // habilita a definicao da cor do material a partir da cor corrente
    glEnable( GL_COLOR_MATERIAL );

    // habilita o uso da iluminacao
    glEnable( GL_LIGHTING );

    // habilita a fonte de luz numero 0
    if ( luz[ 0 ].ligada )
        glEnable( GL_LIGHT0 );
    else
        glDisable( GL_LIGHT0 );

    // normaliza os vetores normais
    glEnable( GL_NORMALIZE );

    // habilita o modelo de colorizacao de Gouraud
    if ( tonalizacao == 'F' )
        glShadeModel( GL_FLAT );
    else
        glShadeModel( GL_SMOOTH );
}


// =======================================================================
// Funcao responsavel por desenhar os objetos
void desenha(void)
{
    GLUquadricObj *qobj;
    qobj = gluNewQuadric();

    if ( wireframe )
    {
        gluQuadricDrawStyle( qobj,  GLU_LINE );
    }
    else
    {
        gluQuadricDrawStyle( qobj,  GLU_FILL );
    }

    // Limpa a janela de visualizao com a cor de fundo especificada
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    // seleciona o tipo de matriz para a visualizacao dos objetos (modelos)
    glMatrixMode(GL_MODELVIEW);

    glPushMatrix();

    glTranslatef( transf.dx , transf.dy , transf.dz );
    glRotatef( transf.angx , 1 , 0 , 0 );
    glRotatef( transf.angy , 0 , 1 , 0 );
    glRotatef( transf.angz , 0 , 0 , 1 );
    glScalef( transf.sx , transf.sy , transf.sz );

    glLineWidth( 1 );

    glColor4f( 1.0 , 1.0 , 0.0 , 1.0 );

    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, TEXTURA2);

    glPushMatrix();
    //BASE ==============================================================
    glPushMatrix();

    glPushMatrix();
    glTranslatef(0, -53, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    //gluCylinder( qobj , 40 , 40 , 5 , 50 , 50 );
    glutSolidCylinder(40.0, 2.0, 50.0, 50.0);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -52, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    //gluCylinder( qobj , 40 , 40 , 5 , 50 , 50 );
    gluCylinder(qobj, 40, 30, 2, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -50, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    //gluCylinder( qobj , 40 , 40 , 5 , 50 , 50 );
    glutSolidCylinder(30.0, 1.0, 50.0, 50.0);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -49, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    //gluCylinder( qobj , 40 , 40 , 5 , 50 , 50 );
    gluCylinder(qobj, 30, 5, 3, 50, 50);
    glPopMatrix();

    glPopMatrix();
    // ==========================================================

    //
    //
    //
    glPushMatrix();
    // HASTE =====================================================
    glPushMatrix();

    glPushMatrix();
    glTranslatef(0, -50, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    glutSolidCylinder(5, 18, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -32, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    gluCylinder(qobj, 5, 3, 10, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -22, 0);
    gluSphere(qobj, 5, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -18, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    gluCylinder(qobj, 3, 4, 15, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, -3, 0);
    glRotatef( -90.0 , 1 , 0 , 0 );
    gluCylinder(qobj, 4, 3, 55, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, 52, 0);
    glRotatef(-90.0, 1, 0, 0);
    gluCylinder(qobj, 3, 4.5, 5, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, 57, 0);
    glRotatef(-90.0, 1, 0, 0);
    gluCylinder(qobj, 4.5, 4.5, 10, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, 67, 0);
    glRotatef(-90.0, 1, 0, 0);
    gluCylinder(qobj, 4.5, 3, 7, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0, 84, 0);
    glRotatef(90.0, 1, 0, 0);
    glutSolidCone(4.3, 30, 50, 50);
    glPopMatrix();

    glPopMatrix();
    // ==========================================================




    glPushMatrix();
    // TRAVESSA =================================================
    glPushMatrix();
    glBegin(GL_POLYGON);
        glVertex3f(30, 60, 7);
        glVertex3f(-30, 60, 7);
        glVertex3f(-30, 60, 3);
        glVertex3f(30, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(30, 67, 7);
        glVertex3f(-30, 67, 7);
        glVertex3f(-30, 60, 7);
        glVertex3f(30, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(30, 67, 3);
        glVertex3f(-30, 67, 3);
        glVertex3f(-30, 67, 7);
        glVertex3f(30, 67, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-30, 67, 3);
        glVertex3f(30, 67, 3);
        glVertex3f(30, 60, 3);
        glVertex3f(-30, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(30, 67, 3);
        glVertex3f(30, 67, 7);
        glVertex3f(30, 60, 7);
        glVertex3f(30, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-30, 67, 7);
        glVertex3f(-30, 67, 3);
        glVertex3f(-30, 60, 3);
        glVertex3f(-30, 60, 7);
    glEnd();

    // ======================================= parte da travessa onde apoia-se as cordas dos pratos
    // ======================================= parte esquerda
    glBegin(GL_POLYGON);
        glVertex3f(-30, 62, 7);
        glVertex3f(-37, 62, 7);
        glVertex3f(-37, 60, 7);
        glVertex3f(-30, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-37, 67, 7);
        glVertex3f(-39, 67, 7);
        glVertex3f(-39, 60, 7);
        glVertex3f(-37, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-39, 60, 7);
        glVertex3f(-39, 60, 3);
        glVertex3f(-30, 60, 3);
        glVertex3f(-30, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-37, 67, 7);
        glVertex3f(-37, 67, 3);
        glVertex3f(-37, 60, 3);
        glVertex3f(-37, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-37, 62, 3);
        glVertex3f(-30, 62, 3);
        glVertex3f(-30, 60, 3);
        glVertex3f(-37, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-39, 67, 3);
        glVertex3f(-37, 67, 3);
        glVertex3f(-37, 60, 3);
        glVertex3f(-39, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-37, 67, 3);
        glVertex3f(-37, 67, 7);
        glVertex3f(-37, 60, 7);
        glVertex3f(-37, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-39, 67, 7);
        glVertex3f(-39, 67, 3);
        glVertex3f(-39, 60, 3);
        glVertex3f(-39, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-37, 62, 3);
        glVertex3f(-37, 62, 7);
        glVertex3f(-30, 62, 7);
        glVertex3f(-30, 62, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-39, 67, 3);
        glVertex3f(-39, 67, 7);
        glVertex3f(-37, 67, 7);
        glVertex3f(-37, 67, 3);
    glEnd();

    // ======================================= parte direita

    glBegin(GL_POLYGON);
        glVertex3f(39, 62, 7);
        glVertex3f(30, 62, 7);
        glVertex3f(30, 60, 7);
        glVertex3f(39, 60, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(39, 67, 7);
        glVertex3f(37, 67, 7);
        glVertex3f(37, 62, 7);
        glVertex3f(39, 62, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(39, 67, 3);
        glVertex3f(39, 67, 7);
        glVertex3f(39, 60, 7);
        glVertex3f(39, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(37, 67, 3);
        glVertex3f(39, 67, 3);
        glVertex3f(39, 60, 3);
        glVertex3f(37, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(30, 62, 3);
        glVertex3f(39, 62, 3);
        glVertex3f(39, 60, 3);
        glVertex3f(30, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(39, 60, 3);
        glVertex3f(39, 60, 7);
        glVertex3f(30, 60, 7);
        glVertex3f(30, 60, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(37, 62, 3);
        glVertex3f(37, 62, 7);
        glVertex3f(30, 62, 7);
        glVertex3f(30, 62, 3);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(37, 67, 7);
        glVertex3f(37, 67, 3);
        glVertex3f(37, 62, 3);
        glVertex3f(37, 62, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(39, 67, 3);
        glVertex3f(37, 67, 3);
        glVertex3f(37, 67, 7);
        glVertex3f(39, 67, 7);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(37, 62, 7);
        glVertex3f(37, 62, 3);
        glVertex3f(30, 62, 3);
        glVertex3f(30, 62, 7);
    glEnd();


    glPopMatrix();

    // ==========================================================

    glPushMatrix();
    // CORDAS =====================================================
    glPushMatrix();

    glPushMatrix();
    glTranslatef(57, -6, 7);
    glRotatef(-90.0, 1.0, 0.0, 0.0);
    glRotatef(-18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 74, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(12, -6, 7);
    glRotatef(-90.0, 1.0, 0.0, 0.0);
    glRotatef(18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 73, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(33, -7, -21);
    glRotatef(-71.0, 1.0, 0.0, 0.0);
    //glRotatef(18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 74, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(33, 63, 3);
    glutSolidCylinder(1, 4, 50, 50);
    glPopMatrix();

    // FIM CORDAS DIREITA ============================================

    // CORDAS ESQUERDA ================================================
    glPushMatrix();
    glTranslatef(-57, -6, 7);
    glRotatef(-90.0, 1.0, 0.0, 0.0);
    glRotatef(18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 74, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-12, -6, 7);
    glRotatef(-90.0, 1.0, 0.0, 0.0);
    glRotatef(-18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 73, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-33, -7, -21);
    glRotatef(-71.0, 1.0, 0.0, 0.0);
    //glRotatef(18.0, 0.0, 1.0, 0.0);
    glutSolidCylinder(1, 74, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-33, 63, 3);
    glutSolidCylinder(1, 4, 50, 50);
    glPopMatrix();


    glPopMatrix();
    // ============================================================

    glPushMatrix();
    // PRATOS =====================================================
    glPushMatrix();

    glPushMatrix();
    glTranslatef(-35, -10, 0);
    glRotatef(-90.0, 1, 0, 0);
    gluCylinder(qobj, 20, 25, 5, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-35, -10, 0);
    glRotatef(-90.0, 1, 0, 0);
    glutSolidCylinder(20, 1, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(35, -10, 0);
    glRotatef(-90.0, 1, 0, 0);
    gluCylinder(qobj, 20, 25, 5, 50, 50);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(35, -10, 0);
    glRotatef(-90.0, 1, 0, 0);
    glutSolidCylinder(20, 1, 50, 50);
    glPopMatrix();


    glPopMatrix();
    // ============================================================
    glPopMatrix();

    // cenario

    glColor3d(0.0, 1.0, 0.0);
    glPushMatrix();

    glEnable(GL_TEXTURE_2D);

    glBindTexture(GL_TEXTURE_2D, TEXTURA2);

    glBegin(GL_POLYGON);
        glVertex3f(500, -500, -500);
        glVertex3f(-500, -500, -500);
        glVertex3f(-500, -500, 500);
        glVertex3f(500, -500, 500);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(500, 500, -500);
        glVertex3f(-500, 500, -500);
        glVertex3f(-500, -500, -500);
        glVertex3f(500, -500, -500);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(-500, 500, 500);
        glVertex3f(-500, 500, -500);
        glVertex3f(-500, -500, -500);
        glVertex3f(-500, -500, 500);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(500, 500, -500);
        glVertex3f(500, 500, 500);
        glVertex3f(500, -500, 500);
        glVertex3f(500, -500, -500);
    glEnd();

    glBegin(GL_POLYGON);
        glVertex3f(500, 500, -500);
        glVertex3f(-500, 500, -500);
        glVertex3f(-500, 500, 500);
        glVertex3f(500, 500, 500);
    glEnd();

    glPopMatrix();
    //cenario

    glPopMatrix();
    glPopMatrix();
    glPopMatrix();
    glPopMatrix();

    glPopMatrix();
    glPopMatrix();

    // Executa os comandos OpenGL
    glutSwapBuffers();

    gluDeleteQuadric( qobj );
}

// =======================================================================
void inicializa( void )
{
    // Define a cor de fundo da janela de visualizacao como preta
    //             R     G     B    alfa
    glClearColor( 0.0 , 0.0 , 0.0 , 1.0 );

    transf.dx   = 0.0;
    transf.dy   = 0.0;
    transf.dz   = 0.0;
    transf.sx   = 1.0;
    transf.sy   = 1.0;
    transf.sz   = 1.0;
    transf.angx = 0.0;
    transf.angy = 0.0;
    transf.angz = 0.0;

    camera.posx   = 0;
    camera.posy   = 0;
    camera.posz   = 500;
    camera.alvox  = 0;
    camera.alvoy  = 0;
    camera.alvoz  = 0;
    camera.inicio = 0.1;
    camera.fim    = 5000.0;
    camera.ang    = 45;

    transformacao = 'T';
    eixo = 'X';
    tonalizacao = 'S';
    primitiva = 0;

    wireframe = false;

    passo = 5;

    ambiente[ 0 ] = 0.2;
    ambiente[ 1 ] = 0.2;
    ambiente[ 2 ] = 0.2;
    ambiente[ 3 ] = 1.0;

    // cor
    luz[ 0 ].difusa[ 0 ] = 0.7;
    luz[ 0 ].difusa[ 1 ] = 0.7;
    luz[ 0 ].difusa[ 2 ] = 0.7;
    luz[ 0 ].difusa[ 3 ] = 1.0;

    // bilho
    luz[ 0 ].especular[ 0 ] = 0.9;
    luz[ 0 ].especular[ 1 ] = 0.9;
    luz[ 0 ].especular[ 2 ] = 0.9;
    luz[ 0 ].especular[ 3 ] = 1.0;

    // posicao
    luz[ 0 ].posicao[ 0 ] =   0.0;
    luz[ 0 ].posicao[ 1 ] = 300.0;
    luz[ 0 ].posicao[ 2 ] = 300.0;
    luz[ 0 ].posicao[ 3 ] =   1.0;

    luz[ 0 ] .ligada = true;

    // capacidade de brilho do material
    especularidade[ 0 ] = 0.8;
    especularidade[ 1 ] = 0.8;
    especularidade[ 2 ] = 0.8;
    especularidade[ 3 ] = 1.0;
    espec_material = 10;

    // habilita a transparenica
    glEnable( GL_BLEND );

    // define a forma de calculo da transparencia
    glBlendFunc( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA );

    // Habilita antialiasing
    glEnable( GL_LINE_SMOOTH );

    // Solicita melhor qualidade
    glHint( GL_LINE_SMOOTH_HINT , GL_NICEST );

    // sentido de criacao da face - frente da face - default: GL_CCW
    glFrontFace( GL_CCW );

    // Habilita a remocao de faces
    //glEnable( GL_CULL_FACE );

    // remove faces traseiras - default: traseiras
    //glCullFace( GL_BACK );

    // habilita o z-buffer
    glEnable( GL_DEPTH_TEST );

    define_iluminacao();

    Texturizacao();

    glutSetWindow( jan[ 0 ] );
    glutReshapeWindow( LAR_HELP , ALT_HELP );
    glutPositionWindow( 10 , 10 );

    glutSetWindow( jan[ 1 ] );
    glutReshapeWindow( LAR_INFO , ALT_INFO );
    glutPositionWindow( 10 , 400 );

    glutSetWindow( jan[ 2 ] );
    glutReshapeWindow( LAR_MAIN , ALT_MAIN );
    glutPositionWindow( ( glutGet( GLUT_SCREEN_WIDTH  ) - LAR_MAIN ) / 2 ,
                        ( glutGet( GLUT_SCREEN_HEIGHT ) - ALT_MAIN ) / 2 );
}

// =======================================================================
// Funcao usada para especificar o volume de visualizacao
void especifica_parametros_visualizacao( void )
{
    // seleciona o tipo de matriz para a projecao
    glMatrixMode( GL_PROJECTION );

    // limpa (zera) as matrizes
    glLoadIdentity();

    // Especifica e configura a projecao perspectiva
    gluPerspective( camera.ang , janela.aspecto , camera.inicio , camera.fim );

    // Especifica sistema de coordenadas do modelo
    glMatrixMode( GL_MODELVIEW );

    // Inicializa sistema de coordenadas do modelo
    glLoadIdentity();

    // Especifica posicao da camera (o observador) e do alvo
    gluLookAt( camera.posx , camera.posy , camera.posz , camera.alvox , camera.alvoy , camera.alvoz ,0,1,0);
}

// =======================================================================
// Funcao callback chamada quando o tamanho da janela eh alterado
void altera_tamanho_janela( GLsizei largura , GLsizei altura )
{
    janela.largura = largura;
    janela.altura  = altura;

    // Para previnir uma divisao por zero
    if ( janela.altura == 0 ) janela.altura = 1;

    // Especifica as dimensıes da viewport
    glViewport( 0 , 0 , janela.largura , janela.altura );

    // Calcula o aspecto
    janela.aspecto = janela.largura / janela.altura;

    especifica_parametros_visualizacao();
}

// =======================================================================
// Funcao de tratamento do teclado
void teclado( unsigned char key , GLint x , GLint y )
{
    GLint modificador = glutGetModifiers();

    if ( modificador & GLUT_ACTIVE_ALT)
    {
        // ALT pressionado
        if( key == '-' || key == '_' )
            if( passo - 1 > 0 )
                passo--;

        if( key == '+' || key == '=' )
            passo++;
    }
    else
    {
        if ( key == 27 )
            exit( 0 );

        if ( key >= '0' && key <= '9' )
            primitiva = key-48;

        if ( toupper( key ) == 'L' )
        {
            luz[ 0 ].ligada = !luz[ 0 ].ligada;
            if ( luz[ 0 ].ligada )
                glEnable( GL_LIGHT0 );
            else
                glDisable( GL_LIGHT0 );
        }

        if ( toupper( key ) == 'F')
        {
            if ( tonalizacao == 'F' )
                tonalizacao = 'S';
            else
                tonalizacao = 'F';
            define_iluminacao();
        }

        if ( toupper( key ) == 'I' )
            inicializa();

        if ( toupper( key ) == 'W' )
            wireframe = !wireframe;

        if ( toupper( key ) == 'X' || toupper( key ) == 'Y' || toupper( key ) == 'Z')
            eixo = toupper( key );

        if ( toupper( key ) == 'S' || toupper( key ) == 'R' || toupper( key ) == 'T' )
            transformacao = toupper( key );

        if ( key == 'A')
            if ( camera.ang+passo < 180 )
                camera.ang += passo;

        if ( key == 'a')
            if ( camera.ang-passo > 0 )
                camera.ang -= passo;

        if ( key == '+' || key == '=')
            switch( transformacao ){
                case 'S':
                    if ( eixo == 'X')
                        transf.sx += 0.1;
                    if ( eixo == 'Y')
                        transf.sy += 0.1;
                    if ( eixo == 'Z')
                        transf.sz += 0.1;
                    break;

                case 'R':
                    if ( eixo == 'X')
                        transf.angx += passo;
                    if ( eixo == 'Y')
                        transf.angy += passo;
                    if ( eixo == 'Z')
                        transf.angz += passo;
                    break;

                case 'T':
                    if ( eixo == 'X')
                        transf.dx += passo;
                    if ( eixo == 'Y')
                        transf.dy += passo;
                    if ( eixo == 'Z')
                        transf.dz += passo;
                    break;
            }

        if ( key == '-' || key == '_' )
            switch( transformacao ){
                case 'S':
                    if ( eixo == 'X')
                        transf.sx -= 0.1;
                    if ( eixo == 'Y')
                        transf.sy -= 0.1;
                    if ( eixo == 'Z')
                        transf.sz -= 0.1;
                    break;

                case 'R':
                    if ( eixo == 'X')
                        transf.angx -= passo;
                    if ( eixo == 'Y')
                        transf.angy -= passo;
                    if ( eixo == 'Z')
                        transf.angz -= passo;
                    break;

                case 'T':
                    if ( eixo == 'X')
                        transf.dx -= passo;
                    if ( eixo == 'Y')
                        transf.dy -= passo;
                    if ( eixo == 'Z')
                        transf.dz -= passo;
                    break;
            }

    }
    especifica_parametros_visualizacao();

    glutSetWindow( jan[ 1 ] );
    glutPostRedisplay();

    glutSetWindow( jan[ 2 ] );
    glutPostRedisplay();
}

// =======================================================================
// tratamento das teclas especiais (teclas de funcao e de navegacao).
// os parametros que recebe sao a tecla pressionada e a posicao x e y
void teclas_especiais( GLint key , GLint x , GLint y )
{
    GLint modificador = glutGetModifiers();

    if ( modificador & GLUT_ACTIVE_ALT)
    {
        // ALT pressionado

        if ( key == GLUT_KEY_LEFT )
            luz[ 0 ].posicao[ 0 ] -= passo*3;

        if ( key == GLUT_KEY_RIGHT )
            luz[ 0 ].posicao[ 0 ] += passo*3;

        if ( key == GLUT_KEY_UP )
            luz[ 0 ].posicao[ 1 ] += passo*3;

        if ( key == GLUT_KEY_DOWN )
            luz[ 0 ].posicao[ 1 ] -= passo*3;

        if ( key == GLUT_KEY_PAGE_DOWN )
            luz[ 0 ].posicao[ 2 ] += passo*3;

        if ( key == GLUT_KEY_PAGE_UP )
            luz[ 0 ].posicao[ 2 ] -= passo*3;

        define_iluminacao();
    }
    else
    {
        if ( key == GLUT_KEY_LEFT )
        {
            camera.posx  -= passo;
            camera.alvox -= passo;
        }

        if ( key == GLUT_KEY_RIGHT )
        {
            camera.posx  += passo;
            camera.alvox += passo;
        }

        if ( key == GLUT_KEY_UP )
        {
            camera.posy  += passo;
            camera.alvoy += passo;
        }

        if ( key == GLUT_KEY_DOWN )
        {
            camera.posy  -= passo;
            camera.alvoy -= passo;
        }

        if ( key == GLUT_KEY_PAGE_UP ) // aumenta o tamanho da window
        {
            camera.posz  -= passo;
            camera.alvoz -= passo;
        }

        if ( key == GLUT_KEY_PAGE_DOWN) // diminui o tamanho da window
        {
            camera.posz  += passo;
            camera.alvoz += passo;
        }
    }
    especifica_parametros_visualizacao();

    glutSetWindow( jan[ 2 ] );
    glutPostRedisplay();
}

// =======================================================================
// Programa Principal
int main( int argc , char *argv[] )
{
    glutInit( &argc , argv );

    glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH );

    // janela do help
    glutInitWindowSize( LAR_HELP , ALT_HELP );
    glutInitWindowPosition( 10 , 10 );
    jan[ 0 ] = glutCreateWindow( "HELP" );

    // janela do help
    glutInitWindowSize( LAR_INFO , ALT_INFO );
    glutInitWindowPosition( 10 , 400 );
    jan[ 1 ] = glutCreateWindow( "INFO" );

    // janela principal
    glutInitWindowSize( LAR_MAIN , ALT_MAIN );
    glutInitWindowPosition( ( glutGet( GLUT_SCREEN_WIDTH  ) - LAR_MAIN ) / 2 ,
                           ( glutGet( GLUT_SCREEN_HEIGHT ) - ALT_MAIN  ) / 2 );
    jan[ 2 ] = glutCreateWindow( "BALANÇA" );

    // callbacks da janela de help
    glutSetWindow( jan[ 0 ] );
    glutDisplayFunc( desenha_help );
    glutReshapeFunc( altera_tamanho_janela_help );

    // callbacks da janela de help
    glutSetWindow( jan[ 1 ] );
    glutDisplayFunc( desenha_info );
    glutReshapeFunc( altera_tamanho_janela_info );

    // callbacks da janela principal
    glutSetWindow( jan[ 2 ] );
    glutDisplayFunc( desenha );
    glutKeyboardFunc( teclado );
    glutSpecialFunc( teclas_especiais );
    glutReshapeFunc( altera_tamanho_janela );

    // funcao que tem as inicializacoes de variaveis e estados do OpenGL
    inicializa();

    // Ultimo comando. Faz com que todas as janelas criadas sejam mostradas
    // Uma vez neste loop, somente sai quando o programa encerra
    glutMainLoop();

    return 0;
}

